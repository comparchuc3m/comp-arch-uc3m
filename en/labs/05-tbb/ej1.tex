\clearpage
\subsection{Exercise: Parallel Invocation}

All the code for this exercise is in the \textemph{01-invoke} folder.

In this exercise we will see how to execute several independent tasks
in parallel. For this we will use a function that generates
a vector of double precision numbers, where each number is obtained by
multiplying its position by a scale factor.

\subsubsection{Number Generation}

The \cppid{generate\_values()} function (see Listing~\ref{lst:genvals}) is an
auxiliary function that will not be modified:

\begin{lstlisting}[label={lst:genvals},caption={Value vector generation}]
  std::vector<double> generate_values(std::size_t n, double factor) {
    std::vector<double> vec;
    vec.reserve(n);
    for (std::size_t i = 0; i < n; ++i) {
      vec.push_back(static_cast<double>(i) * factor);
    }
    return vec;
  }
\end{lstlisting}

\subsubsection{Sequential Execution}

The \cppid{run\_seq()} function executes sequential code that performs
the following tasks consecutively:

\begin{enumerate}

\item Generates 4 vectors of one million values each.

\item Applies to each of the four vectors a transformation that replaces
each value with its double. This is the first time measurement that is performed.

\item Applies to each of the four elements a sequential reduction
operation to sum all elements and divide by the number of elements,
obtaining the average value.

\end{enumerate}

\subsubsection{Parallel Execution}

The \cppid{run\_par()} function originally contains the same code. In this
exercise we will modify it so that the 4 operations of step 2 are performed
in parallel. Then we will do the same with step 3.

For this we can use the \cppid{tbb::parallel\_invoke()} function. This
function takes as a parameter a list of lambda expressions and invokes each one
of them in a separate execution thread, so that they can run in
parallel.

Listing~\ref{lst:par-invoke-ex} presents an example of executing several
functions in parallel.

\begin{lstlisting}[float=htpb!,label={lst:par-invoke-ex},caption={Example of parallel
invocation}]
tbb::parallel_invoke(
  [&]() { task1(); },
  [&]() { tarea2(); },
  [&]() { tarea3(); },
  [&]() { tarea4(); }
);
\end{lstlisting}

Use \cppid{tbb::parallel\_invoke()} so that the four calls to
\cppid{std::transform()} are performed in parallel.

Similarly, use \cppid{tbb::parallel\_invoke()} so that the four
average evaluations (\cppid{avg1}, \cppid{avg2}, \cppid{avg3} and
\cppid{avg4}) are performed in parallel. In this case you cannot place the
variable definitions inside the lambda expressions because they would have
local scope and you could not access them later. But you can define them
before the parallel invocation, giving them an initial value of \cppid{0.0} and then
update them inside the lambda expressions.

\subsubsection{Time Measurement}

Measure the execution times of each of the two stages on the
\textmark{normal} and \textmark{stan} compute nodes.
