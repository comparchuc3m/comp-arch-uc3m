\section{Atomic types}

\begin{frame}[t]{Atomic operations}
\begin{itemize}
\item They are \textmark{indivisible operations}.
    \begin{itemize}

      \mode<presentation>{\vfill\pause}
      \item If a thread performs an \textmark{atomic read} from a variable and  
            other thread performs an \textmark{atomic write } on the same variable and there is no
            \textmark{more threads accessing}:
        \begin{itemize}
          \item The read returns the \textmark{previous value} to the write or the \textmark{written value}.
        \end{itemize}

      \mode<presentation>{\vfill\pause}
      \item If any of the operations (read or write) is \textmark{non atomic} 
            the \textbad{behavior is not defined}.
        \begin{itemize}
          \item A value can be obtained that is not the previous or the subsequent one.
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t]{Atomic types}
\begin{itemize}
  \item A generic type \cppid{atomic<T>} allows to define atomic variables for type \cppid{T}, where \cppid{T} is:
    \begin{itemize}
      \item An integral type.
      \item A floating point type.
      \item A pointer type.
      \item Type \cppid{bool}.
      \item Also available for user defined types fulfilling some constraints.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item All atomic types have a member \cppid{is\_lock\_free()}.
    \begin{itemize}
      \item Determine if their implementation is \textmark{lock-free}.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item Additionally there is a type \cppid{atomic\_flag}:
    \begin{itemize}
      \item The only type that is guaranteed to be \textmark{lock-free}.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{\texttt{\textbf{atomic\_flag}}}
\begin{itemize}
  \item \textmark{Most simple possible} atomic type.
    \begin{itemize}
      \item \textgood{Two possible states}: \textmark{enabled} o \textmark{disabled}.
      \item It is always lock-free.

      \mode<presentation>{\vfill\pause}
      \item Default initialization to disabled.
\begin{lstlisting}
std::atomic_flag f1; // f1 is disabled
\end{lstlisting}

      \mode<presentation>{\vfill\pause}
      \item \textgood{Basic operations}:
        \begin{itemize}
          \item \textmark{Disable}: 
\begin{lstlisting}
f1.clear();
\end{lstlisting}
          \item \textmark{Enable and check} previous value: 
\begin{lstlisting}
f1.test_and_set();
\end{lstlisting}
        \end{itemize}
      \item May provide memory order for operation.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Example: A \emph{spin lock}}
\mode<presentation>{\vspace{-1em}}
\begin{columns}[T]

\column{.5\textwidth}
\begin{itemize}
  \item Lock not using OS services.
    \begin{itemize}
      \item Useful for very short lockings when you desire to avoid context
            switching issues.
    \end{itemize}
  \pause

  \mode<presentation>{\vspace{1em}}
  \item Initially disabled.

  \mode<presentation>{\vspace{1em}}
  \item \cppid{lock()}:
        Enables flag.
    \begin{itemize}
      \item If previously enabled $\Rightarrow$ repeat.
    \end{itemize}

  \mode<presentation>{\vspace{1em}}
  \item \cppid{unlock()}:
        Disables flag.
\end{itemize}

\column{.5\textwidth}
\begin{block}{spin lock mutex}
\begin{lstlisting}
class spinlock_mutex {
public:
  spinlock_mutex() = default;

  void lock() {
    while (f.test_and_set()) {}
  }

  void unlock() {
    flag.clear();
  }

private:
  std::atomic_flag f;
};
\end{lstlisting}
\end{block}
\end{columns}
\end{frame}

\begin{frame}[t,fragile]{\texttt{\textbf{atomic<bool>}}}
\begin{itemize}
  \item More operations than \cppid{atomic\_flag}.
    \item Can be initiated and assigned with \cppid{bool}s.
    \item Cannot be copied from another \cppid{atomic<bool>}.
    \item Modification: \cppid{a.store(valor)}, \cppid{a.exchange(valor)}.
    \item Query: \cppid{a.load()}.
\end{itemize}

\mode<presentation>{\vfill}
\begin{block}{Example}
\begin{lstlisting}
std::atomic<bool> a;
bool x = a.load(std::memory_order_acquire);
a.store(true);
x = a.exchange(false, std::memory_order_acq_rel);
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Compare and exchange}
\begin{itemize}
  \item Compares atomic value with an \textmark{expected} value.
    \begin{itemize}
      \item If both are equal, the \textmark{desired} value is stored in the atomic.
      \item If not equal, atomic value is loaded into \textmark{expected}.
      \item It always returns success/failure indication.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item Two versions:
    \begin{enumerate}
      \item \cppid{a.compare\_exchange\_weak(e,d)}:
        \begin{itemize}
          \item Allows spurious failures (context switch) in some architectures.
          \item May behave as if \cppid{*}\cppkey{this}\cppid{!=e} even if they are equal.
        \end{itemize}
      \item \cppid{a.compare\_exchange\_strong(e,d)}:
        \begin{itemize}
          \item Does not allow for spurious failures.
        \end{itemize}
    \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{\texttt{\textbf{atomic<T*>}}}
\begin{itemize}
  \item Atomic access to a memory address.
  \item Interface similar to \cppid{atomic<bool>}:
    \begin{itemize}
      \item \cppid{is\_lock\_free()}, \cppid{load()}, \cppid{store()}, \cppid{exchange()},
            \cppid{compare\_exchange\_weak()}, \cppid{compare\_exchange\_strong()}.
    \end{itemize}
  \item Additional operations.
    \begin{itemize}
      \item \cppid{fetch\_add(delta)}, \cppid{fetch\_sub(delta)}.
        \begin{itemize}
          \item Return value previous to change.
        \end{itemize}
    \end{itemize}
      \item \cppid{a += delta}, \cppid{a -= delta}.
        \begin{itemize}
          \item Return the value after the change.
        \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{\texttt{\textbf{atomic<integral>}}}
\begin{itemize}
  \item Can be applied to all integral types.
  \item General operations:
    \begin{itemize}
      \item \cppid{is\_lock\_free()}, \cppid{load()}, \cppid{store()}, \cppid{exchange()}, 
            \cppid{compare\_exchange\_weak()}, \cppid{compare\_exchange\_strong()}.
    \end{itemize}
  \item Arithmetic operations.
    \begin{itemize}
      \item \cppid{fetch\_add(value)}, \cppid{fetch\_sub(value)}.
      \item \cppid{a += value}, \cppid{a -= value}.
      \item \cppid{fetch\_and(value)}, \cppid{fetch\_or(value)},
            \cppid{fetch\_xor(value)}.
      \item \cppid{a \&= value}, \cppid{a |= value}, \cppid{a \^{}= value}.
      \item \cppid{++a}, \cppid{a++}, \cppid{-{}-a}, \cppid{a-{}-}
      \item There are no other arithmetic operations (\cppid{*}, \cppid{/}, \cppid{\%}).
    \end{itemize}
\end{itemize}
\end{frame}

