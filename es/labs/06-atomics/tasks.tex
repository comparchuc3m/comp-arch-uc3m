\section{Tareas}

\subsection{Compilación y ejecución}

En esta tarea deberás compilar y ejecutar el programa. 
También compararás las versiones de \emph{Debug} y \emph{Release}.

Compila el proyecto y genera la versión de \emph{Debug}.

Ejecuta el programa generado 3 veces en el servidor \textmark{stan}. 

Anota para cada ejecución, la siguiente información:
\begin{itemize}
\item El valor final de \cppid{counter}.
\item El tiempo de ejecución medido por el programa.
\end{itemize}

Ahora genera una versión de \emph{Release}.

Vuelve a ejecutar el programa en el servidor \textmark{stan} y anota los nuevos resultados.

\subsection{Detección de carreras de datos}

Para detectar las carreras de datos usarás un \textmark{sanitizer} del compilador: 
\textgood{Thread Sanitizer}.

Puedes editar el archivo \textgood{CMakePresets.json} para añadir el flag de
compilación al preset \textmark{default}:

\begin{lstlisting}
"CMAKE_CXX_FLAGS": "-Wall -Wextra -Werror -pedantic -pedantic-errors -Wconversion -Wsign-conversion -fsanitize=thread",
\end{lstlisting}

Como puedes observar se ha añadido un flag de compilación adicional
\textmark{-fsanitize=thread}.

\subsection{Protección con cerrojos}

Protege el dato miembro \cppid{value\_} con un \cppid{std::mutex}. Para ello:

\begin{itemize}
  \item Añade un dato miembro a la clase \cppid{counter} de tipo \cppid{std::mutex}.
  \item Protege mediante el uso del \cppid{std::mutex} las secciones críticas.
\end{itemize}

Coloca estas modificaciones en el directorio \textemph{counter-mutex}.
Comprueba que el programa está libre de condiciones de carrera con
\textmark{Thread Sanitizer}.

\textbad{NOTA}: Todas las evaluaciones se realizarán en el servidor \textmark{stan}.
Evalúa el rendimiento del programa para los casos de 2, 4, 8, 16, 32, 64 y 128 hilos.

\subsection{Protección con un atómico}

En C++20 se pueden utilizar tipos atómicos para proteger valores en coma flotante.
Vamos a utilizar esta propiedad para tener una solución libre de cerrojos.

Cambia el tipo del dato miembro \cppid{value\_} a \cppid{std::atomic<double>}.

Coloca estas modificaciones en el directorio \textemph{counter-atomic}.
Comprueba que el programa esta libre de condiciones de carrera con
\textmark{Thread Sanitizer}.

\textbad{NOTA}: Todas las evaluaciones se realizarán en el servidor \textmark{stan}.
Evalúa el rendimiento del programa para los casos de 2, 4, 8, 16, 32, 64 y 128 hilos.

\subsection{Protección con un \emph{spin lock} y consistencia secuencial}

Ahora estudiaremos los casos en que una variable atómica no es suficiente.
Consideremos el caso en que en vez de un valor se utilizan dos valores en la sección crítica.

\begin{itemize}

  \item Modifica la clase \cppid{counter} para que tenga un segundo dato miembro 
        llamado \cppid{time\_} que será de tipo \cppkey{float}.

  \item Modifica la función \cppid{update()} para que en cada invocación se incremente
        \cppid{time\_} en \cppid{0.25} unidades.

\end{itemize}

Para controlar el acceso a la sección crítica, utiliza un objeto \cppid{spinlock\_mutex} como el siguiente,
que utiliza consistencia secuencial:
\begin{lstlisting}
class spinlock_mutex {
public:
  void lock() {
    while (flag_.test_and_set()) {
      std::this_thread::yield();
    }
  }

  void unlock() {
    flag_.clear();
  }

private:
  std::atomic_flag flag_;
};
\end{lstlisting}

Coloca estas modificaciones en el directorio \textemph{counter-spinseq}.
Comprueba que el programa esta libre de condiciones de carrera con
\textmark{Thread Sanitizer}.

\textbad{NOTA}: Todas las evaluaciones se realizarán en el servidor
\textmark{stan}. Evalúa el rendimiento del programa para los casos de 2, 4, 8,
16, 32, 64 y 128 hilos.

\subsection{Protección con un \emph{spin lock} y consistencia de liberación/adquisición}

Repite el apartado anterior con un \cppid{spinlock\_mutex} que utilice consistencia de
liberación/adquisición:

\begin{lstlisting}
class spinlock_mutex {
public:
  void lock() {
    while (flag_.test_and_set(std::memory_order_acquire)) {
      while (flag_.test(std::memory_order_relaxed)) {
        std::this_thread::yield();
      }
      // spin-wait
    }
  }

  void unlock() { flag_.clear(std::memory_order_release); }

private:
  std::atomic_flag flag_;
};
\end{lstlisting}

Coloca estas modificaciones en el directorio \cppid{counter-spinra}. Comprueba
que el programa esta libre de condiciones de carrera con \textmark{Thread
Sanitizer}.

\textbad{NOTA}: Todas las evaluaciones se realizarán en el servidor \textmark{stan}.
Evalúa el rendimiento del programa para los casos de 2, 4, 8, 16, 32, 64 y 128 hilos.

\subsection{Optimización}

Una alternativa sobre el caso de liberación adquisición es la utilización de
primitivas \cppid{wait()}/\cppid{notify()}:

\begin{lstlisting}
class spinlock_mutex {
public:
  void lock() {
    while (flag_.test_and_set(std::memory_order_acquire)) {
      flag_.wait(true, std::memory_order_relaxed);
    }
  }

  void unlock() {
    flag_.clear(std::memory_order_release);
    flag_.notify_one();
  }

private:
  std::atomic_flag flag_;
};
\end{lstlisting}

Coloca estas modificaciones en el directorio \textemph{counter-spinwn}.
Comprueba que el programa esta libre de condiciones de carrera con
\textmark{Thread Sanitizer}.

\textbad{NOTA}: Todas las evaluaciones se realizarán en el servidor \textmark{stan}.
Evalúa el rendimiento del programa para los casos de 2, 4, 8, 16, 32, 64 y 128 hilos.

